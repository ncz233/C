#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//野指针，指针指向的位置是不可知的（随机的，不正确的，没有明确限制）
//指针未初始化
//指针越界
//指针指向的空间释放
//int main()
//{
//	//这里的p是野指针
//	//int* p;//局部的指针变量，局部变量不初始化，默认放的是随机值
//	//*p = 20;//非法访问内存
//
//	//越界访问
//	//超过指针所在的内容范围
//	//int arr[10] = { 0 };
//	//int* p = arr;
//	//int i = 0;
//	//for ( i = 0; i <= 10; i++)//访问11个，p的最高才10，超过了arr的范围，超过了p就是野指针
//	//{
//	//	*p = i;
//	//	p++;
//	//}
//	return 0;
//}

//指针指向的空间释放
//一开始是属于自己的，然后被释放掉了，这个空间不属于你了，但是指针还是记住这个起始地址，再通过指针访问不行了，因为这个空间已经换给操作系统

//int* test()//因为出数函数的时候创建，出函数的时候销毁。销毁是还给操作系统了
//{
//	int a = 10;
//	return &a;
//}
//int main()
//{
//	int* p = test();
//	*p = 20;
//	return 0;
//}

//怎么避免野指针。
//指针初始化。 尽量所有变量初始化
//小心越界。C语言本身是不会检查数据的越界行为的
//指针指向的空间释放及时置UNLL。当指针被释放时及时把指针变量变成空指针
//指针使用之前要检查有效性

//int main()
//{
//	//当不知道p应该初始化为什么地址的时候，直接初始化为NULL
//	//int* p = NULL;//NULL本质上是0空的意思
//	//明确知道初始化的值
//	//int a = 10;
//	//int* num = a;
//
//	//C语言本身是不会检查数据的越界行为的
//	
//	//指针使用之前要检查有效性
//	int* p = NULL;//已经时空了，不能赋值了
//	if (p != NULL)//这样写有两种结果，一种是空一种是有效的地址，很少出现问题。
//	{
//		*p = 10;
//	}
//	
//
//	return 0;
//}

//指针的运算
//指针+-整数
//指针-指针。指针+指针没意义
//指针的关系运算。如比较大小 

//指针+-整数
//int main()
//{
//	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = a;//数组首元素地址
//	int* pa = a + 9;//数组第10个地址
//	while (p<=pa)
//	{
//		printf("%d\n", *p);
//		*p++;
//	}
//	return 0;
//}

//指针-指针
//指针-指针得到的是指针之间的元素个数
//指针 - 指针的前提是两个指针指向同一块空间
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	char c[5];
//	printf("%d\n", &arr[9] - &c[0]);//不行的
//
//	//printf("%d\n", &arr[9] - &arr[0]);
//	return 0;
//}

#include<string.h>
//递归

//计数器
//int my_strlen(char* a)
//{
//	int i = 0;
//	while (*a != '\0')
//	{
//		i++;
//		*a++;
//	}
//	
//	return i;
//}

//指针的写法
//int my_strlen(char* a)
//{
//	char* start = a;//start记住一开始的位置
//	while (*a != '\0')//计算一共的元素
//	{
//		a++;
//	}
//
//	return a - start;
//}
//
//int main()
//{
//
//	//strlen();//求字符串长度
//	int len = my_strlen("abc");
//	printf("%d\n", len);
//	return 0;
//}

//允许指向数组元素的指针与指向数组最后一个元素后的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置进行比较
//就是往前越界不可以，往后可以
//int main()
//{
//	int a[4] = { 0 };
//	int* i = 0;
//	for ( i = &a[5]; i > &a[0]; )//从右边外面开始，到这个数组的第一个元素
//	{
//		*--i = 0;
//	}
//
//	for (i = &a[5-1]; i > &a[0]; i--)//从这个数组的最后一个元素开始，到左边外面的第一个。尽量不要这样写
//	{
//		*i = 0;
//	}
//
//	return 0;
//}

//指针与数组关系
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", arr);
//	printf("%p\n", &arr[0]);//数组名是数组首元素的地址
//
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 0 };
//	int* p = arr;
//	int i = 0;
//	for ( i = 0; i < 10; i++)
//	{
//		//printf("%p === %p\n", &arr[i], p + i);//p+i就是等于&arr[i]的地址
//		 *(p + i) = i;//就可以这样做，初始化0 - 9
//	}
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", *(p + i));//打印0 - 9
//	}
//
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;//数组名
//	printf("%d\n", arr[2]);
//	printf("%d\n", p[2]);//会在内存中转换成 p[2] -->*(p+2) 而*(p+2)不就是一开始写的吗
//
//
//	//[]是一个操作符 2和arr是两个操作数
//	// 就比如 a+b和b+a 效果一样。  
//	//
//	printf("%d\n", 2[arr]);
//	printf("%d\n",arr[2]);
//	//会在内存中转换成 arr[2] -->*(arr+2) 然后我们得知加法交换不会影响结果 *(2+arr) --> [2]arr 在进行计算的
//
//	//arr[2] == *(p+2) == *(arr+2) == *(2+p) == *(2+arr)
//	//2[arr] == *(2+arr)
//
//	return 0;
//}

//二级指针
//int main()
//{
//	int a = 10;
//	int* pa = &a;//pa是指针变量，一级指针
//	
//	//ppa就是一个二级指针变量
//	int* *ppa = &pa;//pa也是变量，&pa也行意思是取出pa在内存中起始地址。可以理解套娃
//	//int*是pa的类型，*ppa这颗*告诉我ppa是指针它指向pa的
//	//*ppa == pa   *pa == a;  所以得出**ppa == a;
//	int*** pppa = &ppa;//三级指针  意思和上面一样：套娃
//
//	return 0;
//}

//指针数组，本质上是数组
// 
//好孩子，本质上是孩子
//int main()
//{
//	int arr[10];//整型数组 - 存放整形的数组就是整型数组
//	char ch[5];//字符数组 - 存放的是字符
//	//指针数组 - 存放指针的数组
//	int* parr[5];//整型指针的数组
//	char* pch[5];//字符指针的数组
//	return 0;
//}

//结构体
//结构的基础知识
//数组：数组是一组相同元素的集合，用的是{}号
//结构体：也是一些值的集合，但是值的类型可以不同，也是{}号
//
//struct b
//{
//	char c;
//	short s;
//	double f;
//};
//struct stu//stu是名字
//{
//	//成员变量
//	struct b ab;//结构体的成员可以是另外一个结构体
//	char name[20];//名字
//	int age;//年龄
//	char id[20];
//}s1,s2;//s1和s2也是结构体变量
////s1和s2是全局变量
//
//int main()
//{
//	//a是局部变量
//	struct stu a = { {'w',20,3.14},"张三",30,"20200534"};//a对象 初始化
//	//{}括号中的{}括号是为了初始化struct b的
//	//. ->
//	//printf("%c ", a.ab.c);
//	//printf("%s ", a.id);
//
//	struct stu* ps = &a;
//	printf("%c ", (*ps).ab.c);
//	printf("%c ", ps->ab.c);//结构体访问自己的时候不用->,用.
//
//	return 0;
//}

//struct b
//{
//	char c;
//	short s;
//	double f;
//};
//struct stu//stu是名字
//{
//	//成员变量
//	struct b ab;//结构体的成员可以是另外一个结构体
//	char name[20];//名字
//	int age;//年龄
//	char id[20];
//};
//void print(struct stu t)
//{
//	printf("%c %d %lf %s %d %s\n", t.ab.c, t.ab.s, t.ab.f, t.name, t.age, t.id);
//}
//void print1(struct stu* ps)
//{
//	printf("%c %d %lf %s %d %s\n", ps->ab.c, ps->ab.s, ps->ab.f, ps->name, ps->age, ps->id);
//
//}
//int main()
//{
//	//a是局部变量
//	struct stu a = { {'w',20,3.14},"张三",30,"20200534" };//a对象 初始化
//	//写一个函数打印a的内容
//	print(a);//传值调用，传的空间大，参数压栈开销比较大。因为结构体占的内存比较大
//	print1(&a);//传址调用，这个好，效率高。传的时候站的内存是4字节
//	//函数调用的参数压栈
//	// 栈：是一种数据结构
//	// 先进的后出，后进的先出
//	//
//
//
//	return 0;
//}

//栈的工作状态
int add(int x, int y)//每一个函数的调用都会在内存的栈区上开辟一块空间
{
	int z = 0;
	return z = x + y;
}
int main()//main实在栈区的最底层
{
	int a = 3;
	int b = 5;
	int c = 0;
	c = add(a, b);

	return 0;
}
//函数栈帧的创建和销毁
