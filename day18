#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//补充
//release版本可能进行相应的优化
//int main()
//{
//	int i = 0;
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//
//	printf("%p\n", &i);
//	printf("%p\n", &arr[9]);
//	//for ( i = 0; i <= 12; i++)
//	//{
//	//	arr[i] = 0;
//	//	printf("haha\n");
//	//}
//	//release版本没有死循环
//	return 0;
//}

//数据的存储
//整型家族:取值范围定格在limist.h
//浮点型家族:取值范围定格在dloat.h
//构造类型 - 自定义类型 - 自己创建的
//  数组
//  struct结构体类型
//  enum枚举
//  union联合体
// 
//指针类型
//  int*
// char*
// float*
// void*
// 
//空类型
//void
//函数的返回类型 void test()
//函数参数 void test(void)
//指针void* p
//
//int main()
//{
//	int a = -10;
//	int b = 10;
//	//00000000000000000000000000001010 - 二进制
//	//0000000a - 十六机制 - 4个二进制等于1个十六进制
//	//
//
//	//10000000000000000000000000001010 - 源码
//	//11111111111111111111111111110101 - 反码
//	//11111111111111111111111111110110 - 补码
//	//ffffff6
//
//	return 0;
//}
//数据在内存中以2进制的形式存储
//对于整数来说：
//整数二进制有3种表示方式：源码、反码、补码
//正整数：源码、反码、补码相同
//负整数：源码、反码、补码要进行计算
//
//按照数据的数值直接写出二进制序列就是原码
//原码符号位不变，其他按位取反，就是反码
//反码+1，得到的就是补码
//


//为什么用补码运算呢
//cpu是只有+法的
//int main()
//{
//	//1-1
//	//1+(-1)
//	//00000000000000000000000000000001
//	//10000000000000000000000000000001
//	//10000000000000000000000000000010
//	//原码运算是 -2
//	
//	//00000000000000000000000000000001
//	//11111111111111111111111111111111
//	//100000000000000000000000000000000 - 进一位放不下，最前面的丢了是
//	//00000000000000000000000000000000
//	//补码运算是 0
//	//
//	//算出-1的补码
//	//10000000000000000000000000000001
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111
//	//一般反过来就是补码-1 - 反码取反 - 源码   负整数的值
//	//还可以 补码取反 - 反码+1 - 源码   负整数的值
//	//11111111111111111111111111111111
//	//10000000000000000000000000000000
//	//10000000000000000000000000000001
//	//
//	return 0;
//}

//为什么是倒着存的呢
//大端字节序:把数据的低位字节序的内容存放在高地址处，高位字节序的内容存放在低位地址处
//小端字节序:把数据的低位字节序的内容存放在低地址处，高位字节序的内容存放在高位地址处
//
//int main()
//{
//	int a = 0x11223344;//十六进制，高位是11，低位是44
//
//	return 0;
//}

//练习
//写小程序判断当前机器的字节序

//int aaa()//不够简洁
//{
//	int a = 1;
//	char* p = (char*)&a;//a本身是int*类型，我们要强制转换
//	if (*p == 1)
//	{
//		return 1;
//	}
//	return 0;
//}

//int aaa()
//{
//	int a = 1;
//	char* p = (char*)&a;//a本身是int*类型，我们要强制转换
//	return *p;
//	
//}
//int main()
//{
//	if (aaa() == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//
//	return 0;
//}

//int main()
//{
//	char a = -1;
//	//11111111111111111111111111111111
//	//-1的补码
//	//因为-1是整型所以进入char里要截断
//	//而char是1个字节，8个bit位，所以取后8位
//	//11111111
//	signed char b = -1;
//	//同上
//	//11111111
//	unsigned char c = -1;
//	//同上
//	//11111111 - 无符号的会无视符号位，把符号位看成普通位
//	printf("%d %d %d", a, b, c);
//	//然后要打印成10进制的数字，需要补位 - 第一位是什么就补什么，是1补1，是0补0。但是无符号会补0
//	return 0;
//}
//补充
// 1.char到底是signed char 还是unsigned char ？
// C语言标准并没有规定，取决于编译器
// 
// int是sigend int
// short是signed short
//

//int main()
//{
//	char a = -128;
//	//11111111111111111111111110000000 - 补码，
//  //10000000 - char a里的值
//  //因为要打印无符号数，而无符号数是整型也就是8个字节32bit位要补位，然后在进行无符号打印
//  //11111111111111111111111110000000
//	//但是无符号看到它就认为它是正整数，而整数的补码就是源码。
//	printf("%u\n", a);//%u打印的是一个无符号数
//
//	return 0;
//}

//int main()
//{
//	char  a = 128;//因为char的最大值是127，如果超了127，会按照负数来计算。
//	//00000000000000000000000010000000
//	//10000000
//	//和上面一样
//	printf("%u\n", a);
//	return 0;
//}

//char类型的取值范围
//正数
//00000000
//00000001
//........
//01111111
// 
// 负数
//10000000 - 如果看到char类型1000000，1后面7个0，他会直接被解析成-128
//10000001
//........
//11111111
//
//范围-128 -- 127

//int main()
//{
//	int i = -20;
//	//10000000000000000000000000010100
//	//11111111111111111111111111101011
//	//11111111111111111111111111101100
//	//
//	unsigned int j = 10;
//	//00000000000000000000000000010100
//	printf("%d\n", i + j);//以结果打印所以是-10
//	//if (i+j >0)//这是存到了一个地方然后需要整型提升int提升到unsigned int
//	//00000000000000000000000000001010
//	//11111111111111111111111111101100
//	//11111111111111111111111111110110 - 补码
//	//10000000000000000000000000001001
//	//10000000000000000000000000001010 -> -10
//	//
//	return 0;
//}

//int main()
//{
//	unsigned int i;
//	for ( i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);//放在这里 i 就是一块内存区域，打印什么还是要看前面要打印什么类型
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for ( i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//128+127=255
//		//-1,-2,-3.....-127,-128,127,126,125....1,0。因为char只能存8bit的东西所以超了会把前面的丢掉
//		//因为是符号，0的ascll值是\0,所以到0就停下了
//	}
//	printf("%d\n", strlen(a));
//	return 0;
//}

//比如129，它是整数
//00000000000000000000000010000001 - 129
//char类型截取前8
//10000001 - 补码
//然后，第一位是符号位。这个是负数
//这个是是补码，因为计算机里存的整数是补码
//要变成源码
//11111110 - 反码
//11111111 - 源码
//-127

//int main()
//{
//	unsigned char i = 0;
//	for ( i = 0; i <= 255; i++)
//	{
//		printf("hello word");
//	}
//	return 0;
//}

//浮点型在内存中存储
//float
//double

int main()
{
	int n = 9;
	float* pf = (float*) &n;
	printf("%d\n", n);
	printf("%f\n", *pf);

	*pf = 9.0;
	printf("%d\n", n);
	printf("%f\n", *pf);
	return 0;
}
