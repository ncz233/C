#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//1E5表示1.0*10的5次方
//浮点数的存储和取出方式和整数不一样
//结论：浮点数和整数在内存中存储的方式一定是有区别的
//int main()
//{
//	int n = 9;
//	float* pf = (float*)&n;
//	printf("%d\n", n);//二进制序列
//	//00000000000000000000000000001001
//	printf("%f\n", *pf);//以浮点数的视角去看的，他认为这个二进制序列是浮点数
//	//0 00000000 00000000000000000001001
//	//它会看到E为全0是直接1-127 = 126 得出126
//	//00000000000000000001001 * 2^-126 这个数会超小，无线接近于0的数；
//	//
//
//	*pf = 9.0;//以浮点数的视角，存储9.0
//	//00000000000000000000000000001001.0  简便 1001.0
//	//1.001 * 2^3
//	//因为存进去1.001的小数点前的1会省略
//	//0 10000010 0001000000000000000000
//	printf("%d\n", n);//以整数的视角去看
//	//0100000100001000000000000000000 - 看的是补码，第一位是0，所以补码 = 反码 = 源码
//	printf("%f\n", *pf);//浮点数的形式看
//	//0 10000010 0001000000000000000000
//	return 0;
//}

//验证：浮点数和整数在内存中存储的方式一定是有区别的
//浮点数公式(-1)^S * M * 2^E
//S代表符号位0是正，1是负，只有这两种选择，M * 2^E 代表二进制的科学计数法，又因为是二进制的科学计数法所以1<=M<2,因为是二进制的科学计数法 小数点前的数一定是1，所以会把1给省略取而代之的是精度变高。
//没省略1会把1算上会占用1个bit位置，把1省略会精度变高 - 注意这只是计算机自己没有存进去，把1省略了。但是我们达到的数字是前面少了1，所以我们书写的时候把1加上
//可以看成M只存小数点后的数字，如果小数点后面的数字不够，会补齐补0；
// 
//浮点数的存储
//5.5 - 10十进制
//变成二进制是101.1 //.1是2的-1次方，可以理解是...... 2^2  2^1  2^0  . 2^-1  2^-2 ......   看成4 2 1 . 0.5
//转换成科学计数法的形式  1.011*2^2  ->  (-1)^0*1.011*2^2
//(-1)^0*1.011*2^2  解析：0代表符号位0是正，1是负，只有这两种选择。 1.011*2^2代表二进制的科学计数法
//
//模型 float的长度是4个字节，32bit位
//那这个举列 (-1)^S * M * 2^E
//第一位是符号位S   后8个E   最后的23是M
//注意：E是没有符号的。是无符号整数，所以这里的E只能是正数
// 
//模型 double 的长度是8个字节，64bit位
//浮点型公式一样(-1)^S * M * 2^E
//第一位是符号位S   后11个E   最后的52是M
//
//如果float = 0.5；
//会先变成二进制0.1
//公式是 (-1)^S * 1.0 * 2^-1
//这时候E = 负数了，所以存入内存的时候必须加入一个中间值
//
//所以不管E是正数还是负数都要加上(float)127 (double)1023
//float: -1+127 = 126;
// 126存入进去
//double: -1+1023 = 1022;
// 1022存入进去
//

//int main()
//{
//	float f = 5.5f;
//	//101.1
//	//1.011 * 2^2
//	//s = 0  m = 1.011  e = 2
//	//s = 0  m = 011  e = 2+127
//	//0 10000001 01100000000000000000000
//	//0100 0000 1011 0000 0000 0000 0000 0000 - 十六进制
//	//40        b0        00        00
//	//浮点数在内存存储依旧按照大小端来存储
//	return 0;
//}

//拿出来用有3种情况 
//E全不为0或全不为1情况
//因为存进去是加上(float)127 (double)1023
//所以取出来会减去(float)127或者(double)1023
// 
//全是0 那就是真实的E太小 加了127还是0 所以真实的E是-127，是无线接近于0的数字 直接拿1-127 = 126
//其实就是表示0
// 
//全是1 真实的E是128，加了127 是255全是1，非常大的数字，+- 无穷大的数字 +-取决于S位置


//指针的进阶
//字符指针
//数组指针
//指针数组
//数组传参和指针传参
//函数指针
//函数指针数组
//指向函数指针数组的指针
//回调函数
//指针和数组面试题的解析

//int main()
//{
//	//char ch = 'w';
//	//char* pc = &ch;
//
//	//本质上是把"hello wolrd"这个字符串的首字符的地址存储在了ps中
//	char* ps = "hello wolrd";//char*是放不下hello wolrd因为这个是12个字节包括\0，所以存的是首字符h放到*ps，ps是存hello wolrd,所有的指针字节占4字节(32位)或8字节(64位),为什么有类型，因为移动大小，char移动一字节
//	//常量字符串，不能改，实际上这个地方不能改，但是语法可以。引起冲突，所以最好加上const
//	char arr[] = "hello wolrd";//这种的是全存储里了，因为一个是变量一个是数组。但是访问形式可以一样。arr是代表数组首字符的地址，所以arr就是h的地址。这两个有点像
//	*ps = 'w';//这个不行常量字符串是不能被改的
//	//arr[0] = 'w';//这个是没问题的，初始化了一下
//
//	//printf("%c\n", *ps);
//	//printf("%s\n", ps);//
//	//printf("%s\n", arr);//给一个字符串的起始地址就可以打印后面的内容
//
//	return 0;
//}

//int main()//a1和a2是两个空间的所以内存中不一样
//{
// //虽然放的都是一样
//	char a1[] = "hello";
//	char a2[] = "hello";
//	char* a3 = "hello";//常量字符串，字符串内容是不能改的
//	char* a4 = "hello";//因为都不能改，没有必要存在两份，内存中只存在一份，所以共用一份
//
//	if (a1 == a2)
//	{
//		printf("12相同\n");
//	}
//	else
//	{
//		printf("12不相同\n");
//
//	}
//	if (a3 == a4)
//	{
//		printf("34相同\n");
//	}
//	else
//	{
//		printf("34不相同\n");
//
//	}
//
//	return 0;
//}

//指针数组
//int main()
//{
//	//指针数组 - 本质上是数组
//	//数组 - 数组中存放的是指针(地址)
//	//int* arr[4];//存放整型指针的数组
//	//用途
//	//int a = 10;
//	//int b = 20;
//	//int c = 30;
//	//int* arr[3]= { &a,&b,&c };
//	//int i = 0;
//	//for ( i = 0; i < 3; i++)
//	//{
//	//	printf("%d\n", *(arr[i]));
//	//}
//
//	int a[5] = { 1,2,3,4,5 };
//	int b[] = { 2,3,4,5,6 };
//	int c[] = { 3,4,5,6,7 };
//
//	int* arr[3] = { a,b,c };
//
//	int i = 0;
//	for ( i = 0; i < 3; i++)//第几个 
//	{
//		int j = 0;
//		for ( j = 0; j < 5; j++)//第几个的后面数字
//		{
//			//printf("%d", *(arr[i] + j));
//			printf("%d", arr[i] [j]);//模拟了二维数组
//		}
//		printf("\n");
//	}
//
//	return 0;
//}

//int main()
//{
//	float a = 9.0;
//	int* pa = (int*)&a;
//	printf("%d", pa);//以%d打印浮点数是需要强制转成整数的
//	return 0;
//}

//数组指针
//是一种指针 - 指向数组的指针
//整型指针 - 指向整型的指针
//int* p;
//字符指针 - 指向字符的指针
//
//int main()
//{
//	int a = 10;
//	int* pa = &a;
//	char ch = 'w';
//	char* pc = &ch;
//
//	int arr[] = { 1,2,3,4,5 };
//	//arr;//arr是数组名的地址 - arr[0]的地址
//	int(* pa)[10] = &arr;//取出的是数组的地址
//	//为什么是加（）呢，是因为pa会和[10]先结合，从而变成指针数组，所以要加（）让*和pa先运算
//	//int(*)[10] = &arr;//(*)是个指针，指向的是[10]是数组，每个元素是int
//	//pa就是一个数组指针 - 其中存放的是数组的地址
//
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	int* pa = &a;
//	char ch = 'w';
//	char* pc = &ch;
//
//	double* d[5];
//	double* (*pd)[5] = &d;//指向那个数组就写多少[]
//	//数组指针
//
//	return 0;
//}

//int main()
//{
//	int arr[10] = { 0 };
//
//	int* p1 = arr;
//	int(*p2)[10] = &arr;
//
//	printf("%p\n", p1);//数组名表述数组首元素的地址
//	printf("%p\n", p1+1);
//	printf("%p\n", p2);//取地址数组表示取数组的地址，数组的起始地址
//	printf("%p\n", p2+1);
//	return 0;
//}

//数组名是首元素地址
//但是有两个例外
//1.sizeof（数组名） - 数组名表示整个数组，计算的是整个数组大小，单位是字节
//2.&数组名 - 数组名表示整个数组，取出的是整个数组的地址
//其他都是数组名是首元素地址

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int(*pa)[10] = &arr;
//	int i = 0;
//	for ( i = 0; i < 10; i++)
//	{
//		printf("%d ", *((*pa) + i));//*((arr[0])+i))  这个*号是把他们括起来解引用找到准确的位置
//	}
//	
//
//	return 0;
//}

//void print1(int x[3][5], int y,int z)
//{
//	int i = 0;
//	int j = 0;
//	for (i = 0; i < y; i++)
//	{
//		for (j = 0; j < z; j++)
//		{
//			printf("%d ", x[i][j]);
//		}
//		printf("\n");
//	}
////p是一个数组指针
//void print2(int(*p)[5],int r,int c)//二维数组的首元素是：第一行所以（*p）是指向第一行的
//{
//	int i = 0;
//	int j = 0;
//	for ( i = 0; i < r; i++)
//	{
//		for ( j = 0; j < c; j++)
//		{
//			printf("%d ", *(*(p+ i)+j));//(p+ i)是行，*(p+ i)是解引用第几行,(*(p+ i)+j)是一行中有多少元素,*(*(p+ i)+j)是解引用一行中有多少数字
//		}//可以看成*(*([])[]),第一个[]理解arr[i]每个元素类型是int[j]。而arr[i]是行，是二维数组的首元素地址也可以写成*p也是行的意思，arr[i]+1是i加1，那*p加1是*(p+1)
//		printf("\n");
//	}
//}
//int main()
//{
//	//int a [5]; &a
//	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
//
//	//print1(arr, 3, 5);
//	print2(arr, 3, 5);//二维数组的首元素是：第一行
//
//	return 0;
//}

//int a1[3];整型数组
//int* a2[5];指针数组
//int (*a3)[5];数组指针 - 该指针能够指向一个数组，数组10个元素，每个元素的类型是int
//int(*a4[5])[3];是存放数组指针的数组，该数组能够存放10个数组指针，每个数组指针能够指向一个数组，数组5个元素，每个元素是int

//数组参数，指针参数
//void tset1(int a1[])
//{}
//void tset1(int a1[10])//这里的10没用加和不加都一样
//{}
//void tset1(int* a1)
//{}
//void tset2(int* a2[20])//什么传参什么接受，里面的20可以省略掉
//{}
//void tset2(int* *a2)//因为存放的是int*而数组名表示首元素的值所以是int*地址，就是一级指针的地址，放二级指针刚刚好
//{}
//int main()
//{
//	int a1[10] = { 0 };
//	int* a2[20] = { 0 };//整型指针的数组，存放int*的数组
//	test1(a1);
//	test2(a2);
//	return 0;
//}

//二维数组传参

//void tset(int a[3][5])
//{}
//void tset(int a[][])//不行，列省略了
//{}
//void tset(int a[][5])//只能省略行
//{}
//void tset(int* a)//不行，因为二维数组名表示第一行的地址
//{}
//void tset(int* a[5])//不行，这个行是数组了，不是指针
//{}
//void tset(int(*a)[5])//指针指向5个元素的地址
//{}
//void tset(int* *a)//传过去的不是二级指针，所以不行
//{}
//int main()
//{
//	int a[3][5] = { 0 };
//	test(a);
//	return 0;
//}

int main()
{
	float a = 9.0;
	float b = *(&a);
	printf("%f", a);
	printf("%f", *(&a));
	printf("%f", b);

	return 0;
}
