#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//函数的递归:把大事化小
// 递归策略：只需要少量的程序就可以描述出解题过程所需要的多次重复计算，打大减少程序的代码量
//函数直接或间接调用自己的编程技巧叫递归

//简单的递归
//int main()//代码自己跑死了
//{
//	printf("hehe");
//	main();//函数自己调用自己容易出现栈溢出错误
//
//	return 0;
//}

//递归例子:无符号整数，打印它的每一位
//两个必要条件，缺一必错。
//1.存在限制条件，当满足这个条件的时候，递归不再继续
//2.每次递归调用之后越来越接近这个限制条件
//void print(unsigned int x)
//{
//	if (x>9)//这个是条件，没有它递归会一直持续下去，直到栈溢出报错。
//	{//print(x / 10);这个是递归返回值会越来越小逼近于递归跳出的条件判断，直到不符合条递归跳出的件判断，才停下来
//		print(x / 10);//这里要调用自己也就是print函数，因为没执行完，下面的printf不能打印。必须执行完调用的print函数。才返回到主print的时候代码才在往下执行。(总结：一直递归下去直到最后一个执行完成，然后一层层返回来。)
//	}
//	printf("%d",x % 10);//要if语句中的代码执行完才能打印
//	return;
//}
//int main()
//{
//	unsigned int a = 0;//unsigned是无符号整型
//	scanf("%u ", &a);
//	//函数自己调用自己
//	print(a);//print自己可以打印参数部分数字的每一位
//
//	return 0;
//}

//有两个必要条件还是会出错：  推荐个程序员的知乎的网站：https://stackoverflow.com 要求英文比较好
// 1：不能死递归，都有跳出条件，每次递归逼近跳出条件
// 2.递归层次不能太深
// 
//内存的划分
//栈区：栈区存的是临时的变量 如：全局变量、函数形参  
//堆区：动态内存分配的 如：malloc/free、calloc、realloc
//静态区：放两个东西：全局变量、静态变量

void cuo(int x)
{//跑死了，原因栈区满了。每一个函数调用都要在栈区上给自己分配一块空间。
	if (x < 10000)
	{
		cuo(x + 1);
	}
	return;
}
int main()
{
	cuo(1);

	return 0;
}
