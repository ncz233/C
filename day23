#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//数组名的意义
//1.sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小
//2.&数组名，这里的数组名表示整个数组，取出的是整个数组的地址
//3.除此之外所有的数组名都表示首元素的地址
//int main()
//{
//	//二维数组
//	//sizeof()不会真实的去取访问它
//	//sizeof()内部的表达式是不参与运算的
//	int a[3][4] = { 0 };
//
//	printf("%d\n", sizeof(a));//48  
//	printf("%d\n", sizeof(a[0][0]));//4  第一行第一列元素
//	printf("%d\n", sizeof(a[0]));//16  第一行，a[0]表示第一行
//	printf("%d\n", sizeof(a[0]+1));//4/8  a[0]作为数组名并没有单独放在sizeof内
//								   //也没取去地址，所以a[0]就是第一行第一个数的地址
//								   //a[0]+1，就是第一行第二个元素地址
//	printf("%d\n", sizeof(*(a[0]+1)));//4  第一行第一个元素地址解引用
//	printf("%d\n", sizeof(a+1));//4/8  首元素地址+1 = 第二行地址
//								//a是二维数组数组名，并没有取地址
//								//也没有单独放在sizeof内部，所以a就表示二维数组的第一行的地址
//	printf("%d\n", sizeof(*(a+1)));//16  *(a+1) == a[1]，第二行的地址解引用
//	printf("%d\n", sizeof(&a[0]+1));//4/8  a[0]是第一行的数组名，&a[0]取出第一行地址+1 = 第二行地址
//	printf("%d\n", sizeof(*(&a[0]+1)));//16  第二行地址解引用
//	printf("%d\n", sizeof(*a));//16  a作为二维数组的数组名，没有&，没有单独放在sizeof内部
//							   //a就是首元素地址，及第一行的地址，所以*a就是第一行，计算的是第一行的大小
//	printf("%d\n", sizeof(a[3]));//16  a[3]其实是第四行的数组名（如果有的话）
//								 //所以其实不存在，也能通过类型计算大小
//	printf("%d\n", sizeof(a[-1]));//16  sizeof()内部它不会去真的去访问，是看在sizeof()内部的类型去算的
//
//
//	return 0;
//}

//回忆
//int main()
//{
//	short s = 5;
//	int a = 4;
//	printf("%d\n", sizeof(s = a + 6));
//	printf("%d\n", s);
//
//	return 0;
//}

//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	int* ptr = (int*)(&a + 1);//(&a + 1)是&a地址后的编号，然后因为它是数组指针类型，我们要转成(int*)才能放进int* ptr指针里
//	printf("%d %d", *(a + 1), *(ptr - 1));//2,5  然后指向(&a + 1)是&a地址后的数-1(挪动了一个整型)是从指向那个数-1(挪动了一个整型)，所以是5
//	//2好理解，
//
//	return 0;
//}

//struct test
//{
//	int num;
//	char* pc;
//	short sd;
//	char cha[2];
//	short sb[4];
//}*p;
////假设p的值为0x100000，如下表达式分别为多少
////已知，结构体test类型的变量大小是20字节
//int main()
//{
//	printf("%p\n", p + 0x1);//100014  p是指向结构体的指针p + 0x1向后挪动了一位，而p是指向结构体的但结构体是20字节所以移动20字节
//	printf("%p\n", (unsigned long)p + 0x1);//100001  强制转换成(unsigned long)整型类型，整型加1就是1
//	//整型类型和整型指针加1不一样，整型类型加1就是相当于10+1，整型指针加1相当于向后移动了4位(指针类型加1决定加几是指针类型，结构体指针加1就是结构体大小，整型指针加1加4)
//	printf("%p\n", (unsigned int*)p + 0x1);//100004  强制转换成(unsigned int*)整型指针，整型指针加1是向后移动4个字节或8个字节
//
//	return 0;
//}

//int main()
//{
//	//内存存的是16进制的数
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);//a的后面1位
//	//#int* ptr2 = (int*)((int)a + 1);//让a首元素强制类型转换成整型然后加1之后又强制类型转换成整型指针(这时候之前的+1就加了一个字节，向后访问1个字节)赋给了ptr2 00000001 - int+1 - 02000000 01
//	printf("%x %x", ptr1[-1], *ptr2);//*(ptr-1)
//
//	return 0;
//}

//int main()
//{
//	int a[3][2] = { (0,1),(2,3),(4,5) };//逗号表达式是最后的结果，每个括号里是一个结果：1，3，5
//	int* p;
//	p = a[0];
//	printf("%d", p[0]);
//
//	return 0;
//}

//int main()
//{
//	int a[5][5];// 一共5行每行5个
//	int(*p)[4];//int (*)[4]  每行4个  赋给p的是后有类型差异
//	p = a;//int (*) [5]  每行5个
//	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//都是第四行第二个，p比a少1列，所以p会比a小，画图好理解
//	//最后是-4和-4，因为第一个-4是地址打印所以先变成补码1111 1111 1111 1111 1111 1111 1111 1100 分别是16进制中f f f f f f f c
//
//	return 0;
//}

//int main()
//{
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* ptr1 = (int*)(&aa + 1);//取aa后的第一个地址
//	int* ptr2 = (int*)(*(aa + 1));//首元素地址加1是6 = aa[1] = 第二行数组名 ,已经得到整型的地址，(int*)只是迷惑你，没有意义
//	printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1));//10 5 
//
//	return 0;
//}

//int main()
//{
//	char* a[] = { "work","at","alibaba" };//指针数组，char*work
//	char** pa = a;//存到二级指针里
//	pa++;//这个地址里++效果
//	printf("%s\n", *pa);//所以是at
//	return 0;
//}

int main()
{
	//数组名是首元素地址
	char* c[] = { "enter","new","point","first"};
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	printf("%s\n", **++cpp);//point  因为++到下一个地址位置了c+2  注意这里的printf运算是真实的运算，会影响后面的结果。这时候cpp == c+2 == point
	printf("%s\n", *-- * ++cpp + 3);//er   *++cpp是c+1  *--是c+1指向的数的--，所以是enter  +3是从第4位开始打印。这时候cpp == c+1 == enter
	printf("%s\n", *cpp[-2]+3);//st  cpp[-2] == *(cpp-2) == c+3  *(c+3) == fitst  +3是从第4位开始打印。这时候cpp == c+1 == enter，因为没做运算
	printf("%s\n", cpp[-1][-1]+1);//ew   cpp[-1][-1] == *(*(cpp-1)-1) == *(*(c+2)-1) == *((char* point)-1) == new  new+1 == ew
	 
	//画图！！！！！
	return 0;
}
