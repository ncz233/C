#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//[]下标引用操作符
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	//下标来访问的  0 1 2 3 4 5 6 7 8 9
//	printf("%d\n", arr[4]);//[] - 下标引用操作符 - 通过下标找元素
//	//3+5 ， +法的操作符，对应的操作数是2个，一个是3，一个是5
//	//[]的操作数是2个分别是arr,4。两个都不能删掉
//	return 0;
//}

//函数调用操作符
//int add(int x, int y)//函数的定义
//{
//	return x + y;
//}
//void test()
//{
//
//}

//int main()
//{
//	int a = 10;
//	int b = 20;
//	//函数的调用
//	int ret = add(a, b);//() - 函数调用操作符，操作数是add，a，b
//	test();//虽然不传参，但是要调用这函数还是要加()函数调用操作符， 操作数是test
//
//	return 0;
//}

//结构成员访问操作符
//.
//->
//结构体,复杂的东西都可以用结构体
// 比如： 书：书名，书号，定价
// 又比如：人：名字，年龄，性别

//stuct结构体类型
//struct book//创建个自定义类型
//{
//	//结构体成员（变量）
//	char name[20];
//	char id[20];
//	int price;
//
//};//不可缺少的;号
//int main()
//{
//	int unm = 10;//普通类型的使用方式
//	struct book b = { "C语言","c20210509",55 };//信息初始化给b,b是结构体变量名
//	struct book* pa = &b;//b是结构体变量，内存中有b的空间，而b的类型是结构体，所以struct book是b的指针类型
//
//	printf("书名 = %s\n", pa->name);//pa是个结构体指针指向那个对象
//	printf("书号 = %s\n", pa->id);
//	printf("价格 = %d\n", pa->price);
//
//	//printf("书名 = %s\n", (*pa).name);//(*pa)里存的就是b
//	//printf("书号 = %s\n", (*pa).id);
//	//printf("价格 = %d\n", (*pa).price);
//	
//	//结构体变量名.成员名
//	//printf("书名 = %s\n", b.name);
//	//printf("书号 = %s\n", b.id);
//	//printf("价格 = %d\n", b.price);
//	return 0;
//}

//表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定
//同时，有些表达式的操作数在求值的过程中可能需要转换为其他类型
// 如隐式转换中的整型提升和算数转换
//
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a + b * 7;//操作符的优先级和结合性决定
//
//	return 0;
//}

//整型提升，向下转换
//cpu是进行相应云运算，而cpu整型运算器的操作数的字节长度一般是int的字节长度，同时也是cpu通用寄存器的长度
//所以表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才送入cpu去执行运算。
//提升时是最高位提升，最高位是1就不断补1知道达到int的数，0就提升0。无符号是0 , 比int大的就不用提升了
//int main()
//{
//	char a = 3;
//	//000000000000000000000000000000011 - int中放的因为是4个字节，32个bit
//	//00000011 - a - char中放的因为是1个字节，8个bit
//	char b = 127;
//	//000000000000000000000000011111111
//	//01111111 - b
//	char c = a + b;//a,b变成int型在计算
//	//000000000000000000000000000000011
//	//000000000000000000000000011111111
//	//000000000000000000000000100000010
//	//10000010 - c
//	//然后要整型打印c所以要做整型提升，最高位补
//	//111111111111111111111111100000010//这是补码，因为计算机内存存的是补码，但是要源码
//	//111111111111111111111111100000001//反码，补码-1
//	//100000000000000000000000011111110//源码
//	// 
//	//发现a，b都是char类型，都没达到int大小
//	//这里就会发生整型提升
//	//
//	printf("%d\n", c);
//	return 0;
//}

//int main()
//{
//	char a = 1;
//	//%u表示按unsigned int格式输出输入，无符号整数
//	printf("%u\n",sizeof(a));//1
//	printf("%u\n",sizeof(+a));//4如果参与运算之后的结果，就是推导出来之后的结果
//	printf("%u\n",sizeof(-a));//4
//	printf("%u\n", sizeof(!a));//4应该是4.
//
//
//	return 0;
//}

//算数转换，向上转换,
//如果某个操作符的各个操作符属于不同的类型，那么除非其中一个操作数的类型转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为寻常算术转换
//就是向字节长的类型转换精度高的转换，类型不相同是要进行算数转换
//int main()
//{
//	int a = 4;
//	float f = 4.5;
//	a + f;//a要向float转换
//
//	return 0;
//}

//操作符的属性
//复杂表达式的求值的三个影响因素
// 1.操作符的优先级。看谁大
// 2.操作符的结合性。顺序
// 3.是否控制求值顺序。逻辑与，逻辑或，条件操作符，逗号
//4.有一些问题表达式  //别写这样的，要拆的足够细
//int main()
//{
//	int a = 3;
//	int b = 5;
//	//int c = a + b * 7;//先算*的优先级决定了计算顺序
//	int c = a + b + 7;//优先级不起作用，结合性决定作用，顺序从左向右
//
//	return 0;
//}

//练习
//int main()
//{
//	int arr[] = { 1,2,(3,4),5 };//()号里是逗号表达式是最后一个为结果
//	printf("%d\n", sizeof(arr));//16
//	return 0;
//}

//#include<string.h>
//int main()
//{
//	char str[] = "holle bit";
//	//sizeof是计算数组所占空间大小，所以空格和\0也算所以是10
//	//strlen求字符串长度，从第一位向后找\0空格也算,\0不算字符串长度的内容，\0只是停下的标志他不算求长度的内容
//	printf("%d\n%d\n", sizeof(str),strlen(str));//10 9
//	//sizeof - 操作符 - 计算变量/类型所占空间大小 - 单位是字节
//	//strlen - 函数 - 求字符串长度 - 找\0之前出现的字符个数
//	return 0;
//}

//实现函数init（）初始化数组全为0
//实现print()打印数组的每个元素
//实现reverse（）函数完成数组元素的逆位
//void init(int arr[], int sz)
//{
//	int i = 0;
//	for ( i = 0; i < sz; i++)
//	{
//		arr[i] = 0;
//	}
//}
//
//void print(int arr[], int sz)
//{
//	int i = 0;
//	for ( i = 0; i < sz; i++)
//	{
//		printf("%d",arr[i]);
//	}
//	printf("\n");
//}
//
//void reverse(int arr[], int sz)
//{
//	int i = 0;
//	int left = 0;
//	int rihgt = sz - 1;
//	while (left<rihgt)
//	{
//		int a = arr[left];
//		arr[left] = arr[rihgt];
//		arr[rihgt] = a;
//		left++;
//		rihgt--;
//	}
//}
//
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	print(arr, sz);
//	reverse(arr, sz);
//	print(arr, sz);
//	init(arr,sz);
//	print(arr, sz);
//	
//	
//	return 0;
//}


//交换两个数组变量,下标对应的元素交换
//int main()
//{
//	int arr1[] = { 1,3,5,7,9 };
//	int arr2[] = { 2,4,6,8,10 };
//
//	int sz = sizeof(arr1) / sizeof(arr1[0]);
//	int i = 0;
//	for ( i = 0; i < sz; i++)
//	{
//		int a = arr1[i];
//		arr1[i] = arr2[i];
//		arr2[i] = a;
//	}
//
//	//这样写是不行的，因为数组名是数组首元素的地址 - 如 0x003467，地址是不能改的
//	//int arr3[] = { 0 };
//	//arr3 = arr1;
//	//arr1 = arr2;
//	//arr2 = arr3;
//
//	return 0;
//}

//指针形象的被称为地址
//int main()
//{
//	int a = 10;//a占4个字节
//	int* pa = &a;//拿到的是a的4个字节中的第一个字节地址,*pa就把它存起来，*号前面的类型是根据a来算的。pa是来存放地址的又可以说pa是指针变量
//	*pa = 20;//*pa找到a，然后赋值20，就是a赋值20
//
//	return 0;
//}

//指针大小是4，在32位的是4，64位的是8
//int main()
//{
//	int* pa;
//	char* pc;
//	float* pf;
//	printf("%d\n", sizeof(pa));
//	printf("%d\n", sizeof(pc));
//	printf("%d\n", sizeof(pf));
//	return 0;
//}

//指针类型的意义
//1.指针类型决定了：指针解引用的权限有多大
//2.指针类型决定了指针走一步走多远（步长）
//int main()
//{
//	int a[10] = { 0 };
//	int* p = &a;
//	char* pc = &a;//加一和减一一样
//	printf("%p\n", p);
//	printf("%p\n", p+1);//这个+1跳过4，因为是存类型不同。是int
//	printf("%p\n", pc);
//	printf("%p\n", pc+1);//这个+1跳过1，因为是存的类型不同。是char
//
//
//	////一个16进制的位等于4个二进制的位
//	//// 1 2 3 4 5 6 7 8 9 a b c d e f
//	////11111111
//	////    8421  加起来是15
//	//int a = 0x11223344;
//	////int* pa = &a;
//	////*pa = 0;
//	//char* pa = &a;
//	//*pa = 0;
//	return 0;
//}

//int main()
//{
//	int a[10] = { 0 };
//	int* p = a;//因为数组本来就是一组数的地址，不需要加&号，一个一个元素访问操作用
//	int i = 0;
//	for ( i = 0; i < 10; i++)
//	{
//		*(p + i) = 1;//初始化a数组
//	}
//
//	return 0;
//}

//int main()
//{
//	int a[10] = { 0 };
//	char* p = a;//一个一个字节操作用
//	int i = 0;
//	for ( i = 0; i < 10; i++)
//	{
//		*(p + i) = 1;//访问一个整型中一个字节
//	}
//
//	return 0;
//}

