#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>
#include<stddef.h>

//结构体内存的对齐
//如何计算
//1.第一个成员在与结构体变量偏移量为0的地址处
//2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处。
// 对齐数编译器默认的一个对齐数，该成员大小的较小值 （VS默认是8）
//3.结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍
// 必须是最大数的整数倍
//总结：
// 1.结构体的第一个成员，放在结构体在内存中存储位置的0偏移处开始
// 2.从第二个成员往后的所有成员，都放在一个对齐数(成员大小和默认对齐数的较小值)的整数的整数倍的地址处
// 3.结构体的总大小是结构体的所有成员的对齐数中最大的那个对齐数的整数倍
// 4.lxinu系统结构体中字节总大小就是结构体大小
//struct S
//{
//	char c1;//0
//	int i;//4-7
//	char c2;//8
//	//因为对齐数是8所以要取8的较小值
//	//结构体的第一个成员，是从0开始的
//	//因为int是4字节取8的倍数最小值是4，所以在4的地址位置
//	//char是1字节因为是8的倍数所以放在8
//  //最后结构体的总大小是最大的数的倍数
//};
//struct S2
//{
//	char c1;
//	int i;
//	double d;//8
//
//};
//
//int main()
//{
//	struct S s = { 0 };
//	printf("%d\n", sizeof(s));
//	struct S2 s2 = { 0 };
//	printf("%d\n", sizeof(s2));//不是最大内存乘个数
//
//
//	return 0;
//}

//练习
//struct S1
//{
//	char c1;//0
//	int i;//4-7
//	char c2;//8
//};//12
//struct S2
//{
//	char c1;
//	char c2;
//	int i;
//};//8
//struct S3
//{
//	double d;
//	char c2;
//	int i;
//};//16
////嵌套
//struct S4
//{
//	char c1;
//	struct S3 s3;
//	double d;
//};//32
//
//int main()
//{
//	struct S1 s1 = { 0 };
//	struct S2 s2 = { 0 };
//	struct S3 s3 = { 0 };
//	struct S4 s4 = { 0 };
//
//	printf("%d\n", sizeof(s1));
//	printf("%d\n", sizeof(s2));
//	printf("%d\n", sizeof(s3));
//	printf("%d\n",sizeof(s4));
//
//	return 0;
//}

//为什么要内存对齐呢
//硬件规定，不是所有的硬件平台都能访问地址上的任意数据，否则抛出硬件异常
//性能原因，因硬件规定，所以读取的时候是几个字节几个字节读的，如果不是对齐，那这个是要读两次的，浪费时间
//总体来说：结构体的内存对齐是拿空间来换取时间的做法

//设计的得当是可以减少内存的
//让空间小的尽量集结在一起
//把默认对齐数改成2
//#pragma pack(2)//改成2
//struct S1
//{
//	char c1;//0
//	//1-3
//	int i;//4-7
//	char c2;//8
//	//9-11
//};//12
//#pragma pack()//取消修改
//
////#pragma pack(1)//就是紧挨着放，有多少就是多少。
////修改默认对齐数，一般是改成偶数2，4，6，8......
//struct S2
//{
//	char c1;
//	char c2;
//	int i;
//};//8
//int main()
//{
//	printf("%d\n", sizeof(struct S1));
//	printf("%d\n", sizeof(struct S2));
//
//	return 0;
//}

//题
//宏偏移量offetof
//offetof(type,member)
//宏以后再将
//struct S
//{
//	char c1;
//	int i;
//	char c2;
//};//8
//int main()
//{
//	printf("%d\n", offsetof(struct S, c1));
//	printf("%d\n", offsetof(struct S, i));
//	printf("%d\n", offsetof(struct S, c2));
//
//
//	return 0;
//}

//结构体传参
//
//struct S
//{
//	int data[1000];
//	int i;
//};
//struct S s = { {1,2,3,4},1000 };
////结构体传参
//void print1(struct S s)
//{
//	printf("%d\n",s.i);
//}
////结构体指针传参
//void print2(struct S* s)
//{
//	printf("%d\n", s->i);
//}
//int main()
//{
//	print1(s);//传结构体
//	//这个传的时候要把结构体全传过去，也就是结构体有多少，传多少，费时间和内存
//	print2(&s);//传结构体指针
//	//传个地址，空间和时间都有好处，以后结构体传参都用地址
//	return 0;
//}

//位段 - 数据被限制 - 帮我们节省空间
//C语言中的位段，位段依附于结构体
//什么是位段呢
// 位段的声明和结构类似，有两个不同
// 1.位段的成员必须是int，unsigned int signed int 或 char. 整型家族
// 2.位段的成员名后边有一个冒号和一个数字
//
//struct A
//{
//  //开辟4字节 - 32bit
//	int a : 2;//a成员占2个bit位
//	int b : 5;//b成员占5个比特位
//	int c : 10;//c成员占10个比特位
//  //15bit位不够用，但是前面的15bit位用不用时不确定的，所以位段时不跨平台的
//  //4个字节 - 32bit
//	int d : 30;//d成员占30个比特位
//  //int最大是32位bit
//
//};
//int main()
//{
//	printf("%d\n", sizeof(struct A));//8字节
//	return 0;
//}

//比如：性别 - 3种状态 - 不需要太大内存
// 00 男
// 01 女
// 10 保密
// 11
// 
//位段的内存分配
//1.位段的成员可以是int，unsigned int signed int 或 char. 整型家族
//2.位段的空间上是按照需要以4字节(int)或者1个字节(char)的方式来开辟的
// 如果是int内存空间是4字节4字节给你开辟空间的如果够用不开辟，不够用时开辟，char是1字节
//3.段位涉及很多不确定因素，段位是不跨平台的，注重可移植的程序应该避免使用位段
//
//列子
//struct S
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//
//};
//int main()
//{
//	struct S s = { 0 };
//	s.a = 10;//010
//	s.b = 12;//0 1100 010
//	s.c = 3;//0 1100 010  00000 011
//	s.d = 4;//0 1100 010  00000 011  00000 100
//	//        6    2      0   3      0   4
//	//得出结论：
//	// 在VS编译器中一个字节内部的数据先使用低地址，在使用高地址。从右向左使用
//	// 当一块空间剩余内容不够我们下一个成员使用的时候，这块空间会浪费掉，这是当前VS编译器中的
//	//仅仅用于VS，一个字节内部的顺序和大小端顺序是没有关系的
//	return 0;
//}

//位段的跨平台问题
//1.int位段被当成有符号还是无符号数是不确定的。
//2.位段中最大位的数目不能确定。(16位机器最大16，32位机器最大32，写成27，在16位机器会出问题的)
// 16位 - int - 2字节 - 16bit
// 32位 - int - 4字节 - 32bit
//3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义
//4.当一个结构包含两个段位，第二个段位成员比较大，无法容纳于第一个段位剩余的位时，是舍弃还剩余还是利用，这是不确定的。
//总结:跟结构相比，位段可以达到相同的效果，可以很好的节省空间，但是有跨平台的问题存在
//和网络中数据的传输有关系，每个成员占一定的位段，小。如果是一个整型int给它。太大了，传输效率不高

//枚举 - 列举
//可能的取值列举出来，可能性少，有限的

//枚举的优点
// 增加代码的可读性和可维护性
// 和#define类型的标识符比较枚举有类型检查，更加严谨。
// 防止命名污染(封装)
// 便于调试
// 使用方便，一次可以定义多个常量

//可以理解：枚举是类型，可以定义变量，但其成员是常量

//声明枚举类型
//注：里面枚举类型的可能取值常量
//enum color//后面的为初始值
//{
//	red = 5,
//	green = 7,
//	blue,
//};
//int main()
//{
//  //这里枚举是可以定义变量的
//	enum colr c = blue;//这里在c++会报错，c++语法检查更加严格
//	printf("%d\n", red);
//	printf("%d\n", green);
//	printf("%d\n", blue);
//
//	return 0;
//}

void menu()
{
	printf("***********************\n");
	printf("*1.add****2.sub********\n");
	printf("****3.mul****4.div*****\n");
	printf("*******0.exit**********\n");
	printf("***********************\n");
}
//枚举类型就是一种类型
enum op//枚举是有类型的不能被修改的，枚举的使用让代码的可读性更高
{
	exit,//0
	add,//1
	sub,
	mul,
	div
};
int main()
{
	int input = 0;
	do
	{
		menu();
		printf("请选择:>");
		printf("%d", &input);
		switch (input)
		{
		case add:
			break;
		case sub:
			break;
		case mul:
			break;
		case div:
			break;
		default:
			break;
		}
	} while (input);
	return 0;
}
